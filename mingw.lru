function add_suff( var, suff, delim )
  if not delim then delim = ' ' end
  if var ~= "" and var:sub(-1,-1) ~= delim then var = var .. delim end
  return var .. suff
end

function init_rules( mode )
  local obj_pref = ''
  local cc_opt = ''
  local ld_opt = ''
  local libs_opt = ''

  local function pref( s ) obj_pref = add_suff(obj_pref, s, '_') end
  local function cc( s ) cc_opt = add_suff(cc_opt, s) end
  local function ld( s ) ld_opt = add_suff(ld_opt, s) end
  local function libs( s ) libs_opt = add_suff(libs_opt, s) end

  -- выводим все полученные опции
  io.write('mode: mingw')
  for mn, mv in pairs(mode) do
    if mv then
      if type(mv) == 'boolean' then
        io.write(', ', mn)
      else
        io.write(', ', mn .. '('..tostring(mv)..')')
      end
    end
  end
  io.write('\n')

  local home_path = os.getenv('lwdg_home')

  pref('mingw')
  if mode.debug then pref('debug') end
  if mode.fastmath then pref('fastmath') end
  if mode.prof then pref('prof') end

  cc('-Wall -mthreads')
  cc('-I${std_inc}')
  cc((mode.debug and '-O0') or '-O2')
  if mode.debug then cc('-gstabs+') end
  if mode.fastmath then cc('-ffast-math') end
  if mode.prof then cc('-pg') end

  ld('-mthreads')
  ld('-L${std_lib}')
  if mode.prof then ld('-pg') end
  if mode.gui then ld('-mwindows') end
  if mode.dll then ld('-shared -Wl,--out-implib,${dst_bn}.a') end

  libs('-llua51')
  if mode.libs then
    for ln in mode.libs:gmatch('%S+') do
      libs('-l' .. ln)
    end
  end

  -- нужно для export функций ниже
  local wx_inc1
  local wx_inc2
  local rc_inc
  local wx_lib

  if mode.wx then
    if mode.wx == true then mode.wx = 'dll' end
    local wx_ver = '2.6'
    local wx_dir = os.getenv('wxwin') .. '/build-lwdg-' .. mode.wx
    wx_inc1 = wx_dir ..'/include/wx-' .. wx_ver
    wx_inc2 = wx_dir .. '/lib/wx/include/msw-ansi-release-' .. (mode.wx == 'static' and 'static-' or '') .. wx_ver
    rc_inc = wx_inc1
    local win_libs =
      '-lrpcrt4 -loleaut32 -lole32 -luuid -lwinspool -lwinmm -lshell32 ' ..
      '-lcomctl32 -lcomdlg32 -lctl3d32 -ladvapi32 -lwsock32 -lgdi32'
    local wx_libs
    if mode.wx == 'static' then
      wx_libs = '-lwx_msw-'..wx_ver ..
        ' -lwxtiff-'..wx_ver .. ' -lwxjpeg-'..wx_ver .. ' -lwxpng-'..wx_ver .. ' -lwxzlib-'..wx_ver ..
        ' ' .. win_libs
    else
      wx_libs = '-lwx_msw_core-'..wx_ver ..  ' -lwx_base-'..wx_ver .. ' -lwx_msw_html-' .. wx_ver
    end

    wx_lib = wx_dir .. '/lib'
    
    if mode.wx ~= 'static' then
      pref('wxdll')
    else
      pref('wxstatic')
    end
    cc('-I${wx_inc1}')
    cc('-I${wx_inc2}')
    cc('-D__WXMSW__')
    if mode.wx ~= 'static' then
      cc('-DWXUSINGDLL')
    end
    ld('-L${wx_lib}')
    libs(wx_libs)
    libs('-llimcov')
  end

  local std_inc = home_path .. '/include'
  local std_inc_ex = '$(LWDG_HOME)/include'
  local std_lib = home_path .. '/lib'

  -- export

  mk_cc = function( dst_fn, src_fn, inc_opt )
    local par = {
      inc_opt = inc_opt, dst_fn = dst_fn, src_fn = src_fn, cc_opt = cc_opt,
      std_inc = std_inc, wx_inc1 = wx_inc1, wx_inc2 = wx_inc2
    }
    return subst('g++ ${cc_opt} ${inc_opt} -o${dst_fn} -c ${src_fn}', par)
  end
  mk_cc_ex = function( dst_fn, src_fn )
    local par = {
      dst_fn = dst_fn, src_fn = src_fn, cc_opt = cc_opt,
      std_inc = std_inc_ex, wx_inc1 = '$(WX_INC)', wx_inc2 = '$(WX_SETUP_INC)'
    }
    return subst('g++ ${cc_opt} -o${dst_fn} -c ${src_fn}', par)
  end
  mk_ld = function( dst_fn, obj_lst, is_export )
    local dst_bn = split(dst_fn).name
    local par = {
      dst_bn = dst_bn, dst_fn = dst_fn, obj_lst = obj_lst, libs_opt = libs_opt, ld_opt = ld_opt,
      std_lib = std_lib, wx_lib = wx_lib
    }
    if is_export then
      par.std_lib = '$(LWDG_HOME)/lib'
      par.wx_lib = '$(WX_LIB)'
    end
    return subst('g++ ${ld_opt} -o${dst_fn} ${obj_lst} ${libs_opt}', par)
  end
  mk_rc = function( dst_fn, src_fn, is_export )
    local rc_opt = ''
    local loc_rc_inc = rc_inc
    if mode.wx then
      rc_opt = '--define __WXMSW__'
      if mode.wx ~= 'static' then
        rc_opt = rc_opt .. ' --define WXUSINGDLL'
      end
      if is_export then loc_rc_inc = '$(WX_INC)' end
    end
    if loc_rc_inc then
      loc_rc_inc = '--include-dir ' .. loc_rc_inc
    else
      loc_rc_inc = ''
    end
    local par = { dst_fn = dst_fn, src_fn = src_fn, rc_opt = rc_opt, rc_inc = loc_rc_inc }
    local cmd_rc = 'windres -i${src_fn} -o${dst_fn} ${rc_opt} ${rc_inc}'
    return subst(cmd_rc, par)
  end
  mk_obj_id = function( dir, name )
    return obj_pref .. '-' .. string.gsub(dir .. name, '[%/%\\]', '__')
  end
end

addpar{
  basedir = basedir,
  rev_slash = false,
  case_sens = false,
  usefile_name = 'llake_use',
  use_cwd = true,

  lib2fname = function( name )
    return name .. '.a'
  end,

  res2fname = function( name )
    return name .. '.rc'
  end,

  export_preambule = {
    "# define variable properly",
    "#LWDG_HOME=path",
    "#WX_MODE=dll",
    "",
    "WX=$(LWDG_HOME)/wx/build-lwdg-$(WX_MODE)",
    "",
    "WX_INC=$(WX)/include/wx-2.6",
    "WX_LIB=$(WX)/lib",
    "WX_SETUP_INC=$(WX_LIB)/wx/include/msw-ansi-release-2.6",
  },

  ['.cc'] = {
    dep_parser = cc.hdr_parser,
    is_nontransitive_dep = false,
    task_parser = cc.lib_parser,

    src2obj = function( basedir, dir, name )
      return basedir .. 'obj/' .. mk_obj_id(dir, name) .. '.o'
    end,

    export_src2obj = function( name )
      return name .. '.o'
    end,

    compile = function( dst_fn, name, dir, paths )
      local inc_opt = ""
      for _, p in ipairs(paths) do
        inc_opt = inc_opt .. '-I' .. p:sub(1,-2) .. ' '
      end
      inc_opt = inc_opt:sub(1, -2)
      local src_fn = dir..name..'.cc'
      return mk_cc(dst_fn, src_fn, inc_opt), 'CC ' .. name .. '.cc'
    end,

    export_compile = function( dst_fn, name )
      local src_fn = name..'.cc'
      return mk_cc_ex(dst_fn, src_fn)
    end,
  },

  ['.h'] = {
    dep_parser = cc.hdr_parser,
    is_nontransitive = false,
    dep2src = function(fn) return split(fn).name .. '.cc' end,
    do_demand_src = false,
    task_parser = cc.lib_parser,
  },

  ['.eh'] = {
    dep_parser = cc.hdr_parser,
    is_nontransitive = false,
  },

  ['.svn'] = {
  },

  ['.xpm'] = {
  },

  ['.a'] = {
    src2obj = function( basedir, dir, name )
      return basedir .. dir .. name .. '.a'
    end,

    export_src2obj = function( name )
      return name .. '.a'
    end,

    weight = 100,
  },

  ['.rc'] = {
    src2obj = function( basedir, dir, name )
      return basedir .. 'obj/' .. mk_obj_id(dir, name) .. '.o'
    end,

    export_src2obj = function( name )
      return name .. '.o'
    end,

    compile = function( dst_fn, name, dir, paths )
      local src_fn = dir..name..'.rc'
      return mk_rc(dst_fn, src_fn), 'RC ' .. name .. '.rc'
    end,

    export_compile = function( dst_fn, name )
      local src_fn = name..'.rc'
      return mk_rc(dst_fn, src_fn, true)
    end,
  },

  link = function( dst_fn, obj_list )
    local obj_lst = ""
    for _, obj in ipairs(obj_list) do
      obj_lst = obj_lst .. obj .. ' '
    end
    obj_lst = obj_lst:sub(1, -2)
    return mk_ld(dst_fn, obj_lst), 'LD ' .. dst_fn
  end,

  export_link = function( dst_fn, obj_list )
    local obj_lst = ""
    for _, obj in ipairs(obj_list) do
      obj_lst = obj_lst .. obj .. ' '
    end
    obj_lst = obj_lst:sub(1, -2)
    return mk_ld(dst_fn, obj_lst, true)
  end,

  strip = function( dst_fn )
    local cmdl = "strip " .. dst_fn
    return cmdl, 'STRIP ' .. dst_fn
  end,

  prepare = function( base_dir, proj_dir )
    local ver = 'none'
    local pipe, err = io.popen(string.format('svnversion %s', '.'))
    if pipe == nil then
      io.stderr:write('cannot get version: ', err, '\n')
    else
      ver = pipe:read('*line') or ver
      pipe:close()
    end

    local file = io.open('revision.svn','wt')
    file:write('// This is automatically generated file -- do not edit!\n\n')
    file:write('#define SVN_VER "', ver,'"\n')
    file:close()
  end,
}
